layout: post
title: 柯里化 与 反柯里化
comment: true
tags: [前端,js]
date: 2018-02-08 10:11:04
updated: 2018-02-08 10:11:04
---

------
### 柯里化
函数柯里化就是对高阶函数的降阶处理。
柯里化简单的说,就是把 n 个参数的函数,变成只接受一个参数的 n 个函数

<!-- more -->

```bash
function(arg1,arg2)变成function(arg1)(arg2)
function(arg1,arg2,arg3)变成function(arg1)(arg2)(arg3)
function(arg1,arg2,arg3,arg4)变成function(arg1)(arg2)(arg3)(arg4)
```
- 柯里化有什么作用
1. 参数复用；
2. 提前返回；
3. 延迟计算/运行

```bash
//求和
function add (a, b, c) {
    return a + b + c
}
add(1,2,3)

```
如果我只改变 c 的值,在求和
add(1,2,4) 是不是得多出重新计算 a + b 的部分
我们是不是可以提前返回a+b的值， 然后只传入 c 的值进行计算就行了
修改一下方法

```bash
function add (a, b) {
    return function (c) {
        return a + b + c
    }
}
var sum = add(1, 2)
sum(3)
sum(4)

```

在此基础上我们在做下修改
```bash
function add (a) {
    return function (b) {
        return function (c) {
            return a + b + c
        }
    }
}

```

这样我们是不是可以随时复用某个参数，并且控制在某个阶段提前返回
还有一个经典的例子
```bash
var addEvent = function(el, type, fn, capture) {
    if (window.addEventListener) {
        el.addEventListener(type, function(e) {
            fn.call(el, e);
        }, capture);
    } else if (window.attachEvent) {
        el.attachEvent("on" + type, function(e) {
            fn.call(el, e);
        });
    } 
};
```

我们每次调用事件时，都需要判断兼容问题， 但我们运用柯里化的方式就只要判断一次就行了
```bash
var addEvent = (function(){
    if (window.addEventListener) {
        return function(el, sType, fn, capture) {
            el.addEventListener(sType, function(e) {
                fn.call(el, e);
            }, (capture));
        };
    } else if (window.attachEvent) {
        return function(el, sType, fn, capture) {
            el.attachEvent("on" + sType, function(e) {
                fn.call(el, e);
            });
        };
    }
})();

```

还有一个作用就是延迟计算
小明每天都会花一部分钱吃饭
小明想知道它5天之后总共会花费多少钱

```bash
var total = 0
var fn = function(num) {
    total += num
}
fn(50)
fn(70)
fn(60)
fn(100)
fn(80)
```
这样我们便能算出它总共花了都少钱
但是小明又突然想知道 如果他每天花费的的钱翻一倍 会产生多少钱
于是我们是不是得改下 上面的 函数

```bash
var fn = function(num) {
    total += num*2
}
fn(50)
fn(70)
fn(60)
fn(100)
fn(80)

```

那我们是不是有什么办法，先把这些数 存起来，到最后在进行计算
我们接着来封装

```bash
var curry = function(fn) {
    var args = []
    return function() {
        if (arguments.length === 0) {
            return fn.apply(null, args)
        }else{
            args = args.concat([].slice.call(arguments))
            return curry.call(null, fn, args)
        }
    }
}

var curryFn = function() {
    var args = [].slice.call(arguments),
        total = 0
    for (var i = 0; i < args.length; i++) {
        total += args[i]
    }
    return total
}
var fn = curry(curryFn)
fn(50)
fn(70)
fn(60)
fn(100)
fn(80)

fn() //不传参数的时候进行计算

```

这样我们只有最后的时候才进行计算。
而且只需要修改 curryFn 里面的计算方法就行
我们整理下上面的方法封装完整的柯里化函数

```bash
var curry = function (fn, length) {
    length = length || fn.length;
    var sub_curry = function (f) {
        var args = [].slice.call(arguments, 1);
        return function () {
            return f.apply(null, args.concat([].slice.call(arguments)))
        }
    }
    return function () {
        var args = [].slice.call(arguments);
        if (length > args.length) {
            var newArgs = [fn].concat(args);
            return curry(sub_curry.apply(null,newArgs), length - args.length)
        }else{
            fn.apply(null,arguments)
        }
    }
}

```

```bash
// 1.
var fn  = curry( function(a,b,c){
    console.log(a, b, c)
})
fn('a')('b')('c')

// 2.
fn1 = curry(function(){
    console.log(arguments)
}, 3)
fn1('a')('b')('c')

```

### 反柯里化
反柯里化的作用在与扩大函数的适用性，使本来作为特定对象所拥有的功能的函数可以被任意对象所用.
被任意对象使用？ 是不是想到了用call, apply 设置this指向
- 通过 call/apply 被任意对象所用
```bash
var obj = {
    a: 1,
    fn: function (b) {
        return this.a + b
    }
}
obj.fn(2) // 3
var obj1 = {a:4}
obj.fn.call(obj1, 2) // 6
```
反柯里化版本
```bash
var uncurrying= function (fn) {
    return function () {
        var context=[].shift.call(arguments);
        return fn.apply(context,arguments);
    }
}
// const uncurrying = fn => (...args) => Function.prototype.call.apply(fn,args) // 简洁版
var f = function (b) {
    return this.a + b
}
var uncurry = uncurrying(f)
var obj = {a:1},
    obj1 = {a:4}
uncurry(obj, 2) // 3
uncurry(obj1, 2) // 3

```

