layout: post
title: 前端异步解决方案
comment: true
tags: [前端,js]
date: 2018-02-08 09:53:02
updated: 2018-02-08 09:53:02
---

------
JavaScript是单线程语言，JS中所有的任务可以分为两种：同步任务和异步任务。

- 同步任务: 
意思是我必须做完第一件事,才能做第二件事,按照顺序一件一件往下执行（在主线程上）
- 异步任务: 
假如我第一件事需要花费 10s, 但是我第二件事急着要做, 于是我们就把第一件事告诉主线程，然后主线程暂停先放到某个地方, 等把第二件事完成之后,再去那个地方执行第一件事，第一件事也就可以理解为异步任务

<!-- more -->

- 任务队列（task queue）:
任务队列是干嘛的呢; 上面我们说了异步任务的情况, 我们把第一件放到某个地方, 那某个地方是什么地方呢,就是 “任务队列” 这个东西。里面乘放的是所有异步任务。
- Event Loop(事件循环)
当主线程上面所有同步任务执行完之后，主线程就会向任务队列中读取异步任务（队列方法：先进先出）
而且是一直重复向任务队列中，即使没有任务。它也会一直去轮询。
只不过在任务列表里面没有任务的时候， 主线程只需要稍微过一遍就行， 一旦遇到任务队列里面有任务的时候，就会去执行它
也就是说在我们打开网页的时候，JS引擎会一直执行事件循环，直到网页关闭
- 如图：

![images](http://wangyuanqi.info/robot/1518054957550.png)

so，我们很需要  callback => promise => async/await

因为很多时候我们需要把一个异步任务的返回值，传递给下一个函数，而且有时候是连续的n个

## callback

```bash
// 只有一个callback的时候
function fn(callback) {
    setTimeout(function(){
        callback && callback()
    }, 1000)
}
fn(function(){
    console.log(1)
})

// 一旦我们多几个呢？
function fn(a){ // 传入a  返回a1
    function fn1(a1){
        function fn2(a2){
            function fn3(a3){
                console.log(a3)
                ....
            }
        }
    }
}
// 当项目一复杂，这滋味。。。

```

## Promise
### 什么是promise?
Promise是异步编程的一种解决方案，同时也是ES6的内置对象，它有三种状态:

1. pending: 进行中
2. resolved: 已完成
3. rejected：已失败

### Promise方法
1. Promise.prototype.then() 接收两个函数，一个是处理成功后的函数，一个是处理错误结果的函数。可以进行链式调用
2. Promise.prototype.catch() 捕获异步操作时出现的异常, 一般我们用来代替.then方法的第二个参数
3. Promise.resolve() 接受一个参数值，可以是普通的值， 会返回到对应的Promise的then方法上
4. Promise.reject() 接受一个参数值，可以是普通的值， 会返回到对应的Promise的catch方法上或着then方法的第二个参数上
5. Promise.all() 接收一个参数，它必须是可以迭代的，比如数组。通常用来处理一些并发的异步操作。成功调用后返回一个数组，数组的值是有序的，即按照传入参数的数组的值操作后返回的结果
6. Promise.race() 接收一个可以迭代的参数，比如数组。但是只要其中有一个执行了，就算执行完了，不管是成功还是失败。

- 基本用法
```bash
let promise = new Promise( (resolve, reject) => {
    setTimeout(function(){
        resolve(1)
    }, 1000)
})
promise.then( res => {
    console.log(res)// 一秒之后打印1
})

```

- 我们把上面的回调地狱转换下
```bash
const fn = a => {
    return Promise.resolve(a)
}
const fn1 = a => {
    return Promise.resolve(a)
}
const fn2 = a => {
    // return Promise.resolve(a)
    return new Promise( (resolve, reject) => {
        setTimeout(function(){
            resolve(a)
        },1000)
    })
}
const fn3 = a => {
    // return Promise.resolve(a)
    return new Promise( (resolve, reject) => {
        setTimeout(function(){
            resolve(a)
        },1000)
    })
}
fn(123)
    .then(fn1)
    .then(fn2)
    .then(fn3)
    .then( res => {
        console.log(res) // => 123
    })

```
这样就简单明了多了， 我们就不需要一层一层嵌套callback了,可以通过链式调用来解决callback的问题

然而，仅仅这样还是觉得不够好
因为这种面条式调用还是让人很不爽，而且 then 方法里面虽然是按先后顺序来的，但是其本身还是异步的
看下面这段代码

```bash
const promise = new Promise( (resolve, reject) => {
    setTimeout(function(){
        resolve(222)
    }, 1000)
})
console.log(111)
promise.then( res => {
    console.log(res)
})
console.log(333)

```

打印结果依然还是 111 => 333 => 222, 并不是我们想象的 111 => 222 => 333
依然不适合单线程的思维模式。所以下一个解决方案 又出现了

## async/await
- 这是ES7的语法，当然，在现在这种工程化的时代，基本babel编译之后也都是能在项目中引用的

- 基本用法跟规则
1. async 表示这是一个async函数，
2. await只能用在这个函数里面。后面应该跟着是 Promise 对象， 不跟的话也没关系， 但是await就不会在这里等待了
3. await 表示在这里等待promise返回结果

```bash
const fn = () => {
    return new Promise( (resolve, reject) => {
        setTimeout(function(){
            resolve(222)
        }, 1000)
    })
}
(async function(){
    console.log(111)
    let data = await fn()
    console.log(data)
    console.log(333)
})()
// 是不是返回 111 => 222 => 333 了呢

// 我们来试下返回别的东西， 不返回 promise
const fn = () => {
    return new Promise( (resolve, reject) => {
        setTimeout(function(){
            resolve(222)
        }, 1000)
    })
}
(async function(){
    console.log(111)
    let data = await fn()
    console.log(data)
    console.log(333)
})()
// 打印结果： 111 => null => 333 => 222
// 当我们不是在await 关键字后面返回的不是 promise 对象时， 它就不会在原地等待 promise执行完再执行， 而是向正常的JS一样执行，把异步任务跳过去

```

### await 关键字必须包裹在 async 函数里面，而且async 函数必须是它的父函数
```bash
const fn = () => {
    let promise = new Promise( (resolve, reject) => {
        setTimeout(function(){
            resolve(222)
        }, 1000)
    })
}

// 这样是不行的，会报错，因为的await关键字的父函数不是 async 函数
const grand = async () => {
    return function parent() {
        let data = await fn()
    }
}

// 这样才行，因为await 的父函数 是一个 async 函数
const grand = () => {
    return async function parent() {
        let data = await fn()
    }
}

```


