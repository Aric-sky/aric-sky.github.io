layout: post
title: 前端异步解决方案
comment: true
tags: [前端,js]
date: 2018-02-08 09:53:02
updated: 2018-02-08 09:53:02
---

------
<!-- more -->

JavaScript是单线程语言，JS中所有的任务可以分为两种：同步任务和异步任务。

- 同步任务: 
意思是我必须做完第一件事,才能做第二件事,按照顺序一件一件往下执行（在主线程上）
- 异步任务: 
假如我第一件事需要花费 10s, 但是我第二件事急着要做, 于是我们就把第一件事告诉主线程，然后主线程暂停先放到某个地方, 等把第二件事完成之后,再去那个地方执行第一件事，第一件事也就可以理解为异步任务

- 任务队列（task queue）:
任务队列是干嘛的呢; 上面我们说了异步任务的情况, 我们把第一件放到某个地方, 那某个地方是什么地方呢,就是 “任务队列” 这个东西。里面乘放的是所有异步任务。
- Event Loop(事件循环)
当主线程上面所有同步任务执行完之后，主线程就会向任务队列中读取异步任务（队列方法：先进先出）
而且是一直重复向任务队列中，即使没有任务。它也会一直去轮询。
只不过在任务列表里面没有任务的时候， 主线程只需要稍微过一遍就行， 一旦遇到任务队列里面有任务的时候，就会去执行它
也就是说在我们打开网页的时候，JS引擎会一直执行事件循环，直到网页关闭
- 如图：

![images](http://wangyuanqi.info/robot/1518054957550.png)

so，我们很需要  callback => promise => async/await

因为很多时候我们需要把一个异步任务的返回值，传递给下一个函数，而且有时候是连续的n个

## callback

```bash
// 只有一个callback的时候
function fn(callback) {
    setTimeout(function(){
        callback && callback()
    }, 1000)
}
fn(function(){
    console.log(1)
})

// 一旦我们多几个呢？
function fn(a){ // 传入a  返回a1
    function fn1(a1){
        function fn2(a2){
            function fn3(a3){
                console.log(a3)
                ....
            }
        }
    }
}
// 当项目一复杂，这滋味。。。

```

## Promise
### 什么是promise?
Promise是异步编程的一种解决方案，同时也是ES6的内置对象，它有三种状态:

1. pending: 进行中
2. resolved: 已完成
3. rejected：已失败

### Promise方法
1. Promise.prototype.then() 接收两个函数，一个是处理成功后的函数，一个是处理错误结果的函数。可以进行链式调用
2. Promise.prototype.catch() 捕获异步操作时出现的异常, 一般我们用来代替.then方法的第二个参数
3. Promise.resolve() 接受一个参数值，可以是普通的值， 会返回到对应的Promise的then方法上
4. Promise.reject() 接受一个参数值，可以是普通的值， 会返回到对应的Promise的catch方法上或着then方法的第二个参数上
5. Promise.all() 接收一个参数，它必须是可以迭代的，比如数组。通常用来处理一些并发的异步操作。成功调用后返回一个数组，数组的值是有序的，即按照传入参数的数组的值操作后返回的结果
6. Promise.race() 接收一个可以迭代的参数，比如数组。但是只要其中有一个执行了，就算执行完了，不管是成功还是失败。

- 基本用法
```bash
let promise = new Promise( (resolve, reject) => {
    setTimeout(function(){
        resolve(1)
    }, 1000)
})
promise.then( res => {
    console.log(res)// 一秒之后打印1
})

```

- 我们把上面的回调地狱转换下
```bash
const fn = a => {
    return Promise.resolve(a)
}
const fn1 = a => {
    return Promise.resolve(a)
}
const fn2 = a => {
    // return Promise.resolve(a)
    return new Promise( (resolve, reject) => {
        setTimeout(function(){
            resolve(a)
        },1000)
    })
}
const fn3 = a => {
    // return Promise.resolve(a)
    return new Promise( (resolve, reject) => {
        setTimeout(function(){
            resolve(a)
        },1000)
    })
}
fn(123)
    .then(fn1)
    .then(fn2)
    .then(fn3)
    .then( res => {
        console.log(res) // => 123
    })

```
这样就简单明了多了， 我们就不需要一层一层嵌套callback了,可以通过链式调用来解决callback的问题

然而，仅仅这样还是觉得不够好
因为这种面条式调用还是让人很不爽，而且 then 方法里面虽然是按先后顺序来的，但是其本身还是异步的
看下面这段代码

```bash
const promise = new Promise( (resolve, reject) => {
    setTimeout(function(){
        resolve(222)
    }, 1000)
})
console.log(111)
promise.then( res => {
    console.log(res)
})
console.log(333)

```

打印结果依然还是 111 => 333 => 222, 并不是我们想象的 111 => 222 => 333
依然不适合单线程的思维模式。所以下一个解决方案 又出现了

## async/await
- 这是ES7的语法，async 会将其后的函数（函数表达式或 Lambda）的返回值封装成一个 Promise 对象，而 await 会等待这个 Promise 完成，并将其 resolve 的结果返回出来。


### 基本用法跟规则
- async

1.async 函数返回的是一个 Promise 对象。async 函数（包含函数语句、函数表达式、Lambda表达式）会返回一个 Promise 对象，如果在函数中 return 一个直接量，async 会把这个直接量通过 Promise.resolve() 封装成 Promise 对象。

2.async 函数返回的是一个 Promise 对象，所以在最外层不能用 await 获取其返回值的情况下，我们当然应该用原来的方式：then() 链来处理这个 Promise 对象，就像这样
```bash
    testAsync().then(v => {
        console.log(v);    // 输出 hello async
    });
```
3.Promise 的特点——无等待，所以在没有 await 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数并无二致。

- await

1. await 是在等待一个 async 函数完成。不过按语法说明，await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值（换句话说，就是没有特殊限定）。
2.await 不仅仅用于等 Promise 对象，它可以等任意表达式的结果，所以，await 后面实际是可以接普通函数调用或者直接量的。

### async/await 的优势在于处理 then 链

- 单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了（很有意思，Promise 通过 then 链来解决多层回调的问题，现在又用 async/await 来进一步优化它）。
- 假设一个业务，分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果。
```bash
    /**
    * 传入参数 n，表示这个函数执行的时间（毫秒）
    * 执行的结果是 n + 200，这个值将用于下一步骤
    */
    function takeLongTime(n) {
        return new Promise(resolve => {
            setTimeout(() => resolve(n + 200), n);
        });
    }

    function step1(n) {
        console.log(`step1 with ${n}`);
        return takeLongTime(n);
    }

    function step2(n) {
        console.log(`step2 with ${n}`);
        return takeLongTime(n);
    }

    function step3(n) {
        console.log(`step3 with ${n}`);
        return takeLongTime(n);
    }
```
现在用 Promise 方式来实现这三个步骤的处理
```bash
    function doIt() {
        console.time("doIt");
        const time1 = 300;
        step1(time1)
            .then(time2 => step2(time2))
            .then(time3 => step3(time3))
            .then(result => {
                console.log(`result is ${result}`);
                console.timeEnd("doIt");
            });
    }

    doIt();

    // c:\var\test>node --harmony_async_await .
    // step1 with 300
    // step2 with 500
    // step3 with 700
    // result is 900
    // doIt: 1507.251ms
```
如果用 async/await 来实现呢，会是这样
```bash
    async function doIt() {
        console.time("doIt");
        const time1 = 300;
        const time2 = await step1(time1);
        const time3 = await step2(time2);
        const result = await step3(time3);
        console.log(`result is ${result}`);
        console.timeEnd("doIt");
    }

    doIt();
```

### await 关键字必须包裹在 async 函数里面，而且async 函数必须是它的父函数
```bash
const fn = () => {
    let promise = new Promise( (resolve, reject) => {
        setTimeout(function(){
            resolve(222)
        }, 1000)
    })
}

// 这样是不行的，会报错，因为的await关键字的父函数不是 async 函数
const grand = async () => {
    return function parent() {
        let data = await fn()
    }
}

// 这样才行，因为await 的父函数 是一个 async 函数
const grand = () => {
    return async function parent() {
        let data = await fn()
    }
}

```


